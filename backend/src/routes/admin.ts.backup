import { Hono } from 'hono';
import { db } from '../db/index';
import { users, devices, pesanan, menu, inventory, syncLogs, conflictLogs } from '../db/schema';
import { eq, desc, and, gte, lte, sql } from 'drizzle-orm';
import { authMiddleware } from '../middleware/auth';

const admin = new Hono();

// All admin routes require authentication
admin.use('/*', authMiddleware);

// Get all users (warungs)
admin.get('/users', async (c) => {
  try {
    const allUsers = await db.query.users.findMany({
      orderBy: [desc(users.createdAt)],
      with: {
        // This will be handled separately as Drizzle relations need to be defined
      }
    });

    // Get device count and order count for each user
    const usersWithStats = await Promise.all(
      allUsers.map(async (user) => {
        const [deviceCount] = await db
          .select({ count: sql<number>`count(*)` })
          .from(devices)
          .where(eq(devices.userId, user.id));

        const [orderStats] = await db
          .select({
            totalOrders: sql<number>`count(*)`,
            totalRevenue: sql<number>`coalesce(sum(${pesanan.total}), 0)`
          })
          .from(pesanan)
          .where(eq(pesanan.userId, user.id));

        const [lastOrder] = await db
          .select({ tanggal: pesanan.tanggal })
          .from(pesanan)
          .where(eq(pesanan.userId, user.id))
          .orderBy(desc(pesanan.tanggal))
          .limit(1);

        return {
          id: user.id,
          email: user.email,
          warungNama: user.warungNama,
          warungAlamat: user.warungAlamat,
          createdAt: user.createdAt,
          deviceCount: Number(deviceCount?.count || 0),
          totalOrders: Number(orderStats?.totalOrders || 0),
          totalRevenue: Number(orderStats?.totalRevenue || 0),
          lastOrderDate: lastOrder?.tanggal || null
        };
      })
    );

    return c.json({
      success: true,
      data: usersWithStats
    });
  } catch (error) {
    console.error('Get users error:', error);
    return c.json({ error: 'Failed to fetch users' }, 500);
  }
});

// Get user details by ID
admin.get('/users/:id', async (c) => {
  try {
    const userId = parseInt(c.req.param('id'));

    const user = await db.query.users.findFirst({
      where: eq(users.id, userId)
    });

    if (!user) {
      return c.json({ error: 'User not found' }, 404);
    }

    // Get devices
    const userDevices = await db.query.devices.findMany({
      where: eq(devices.userId, userId),
      orderBy: [desc(devices.lastSeenAt)]
    });

    // Get order statistics
    const [orderStats] = await db
      .select({
        totalOrders: sql<number>`count(*)`,
        completedOrders: sql<number>`count(*) filter (where ${pesanan.status} = 'completed')`,
        pendingOrders: sql<number>`count(*) filter (where ${pesanan.status} = 'pending')`,
        cancelledOrders: sql<number>`count(*) filter (where ${pesanan.status} = 'cancelled')`,
        totalRevenue: sql<number>`coalesce(sum(${pesanan.total}) filter (where ${pesanan.status} = 'completed'), 0)`
      })
      .from(pesanan)
      .where(eq(pesanan.userId, userId));

    // Get menu items count
    const [menuCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(menu)
      .where(eq(menu.userId, userId));

    // Get inventory items count
    const [inventoryCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(inventory)
      .where(eq(inventory.userId, userId));

    // Get recent orders
    const recentOrders = await db.query.pesanan.findMany({
      where: eq(pesanan.userId, userId),
      orderBy: [desc(pesanan.tanggal)],
      limit: 10
    });

    return c.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          warungNama: user.warungNama,
          warungAlamat: user.warungAlamat,
          createdAt: user.createdAt
        },
        devices: userDevices,
        stats: {
          totalOrders: Number(orderStats?.totalOrders || 0),
          completedOrders: Number(orderStats?.completedOrders || 0),
          pendingOrders: Number(orderStats?.pendingOrders || 0),
          cancelledOrders: Number(orderStats?.cancelledOrders || 0),
          totalRevenue: Number(orderStats?.totalRevenue || 0),
          menuItems: Number(menuCount?.count || 0),
          inventoryItems: Number(inventoryCount?.count || 0)
        },
        recentOrders
      }
    });
  } catch (error) {
    console.error('Get user details error:', error);
    return c.json({ error: 'Failed to fetch user details' }, 500);
  }
});

// Get revenue analytics
admin.get('/revenue', async (c) => {
  try {
    const timeRange = c.req.query('timeRange') || 'month'; // today, 7days, month, 3months, year
    const now = new Date();
    let startDate: Date;

    switch (timeRange) {
      case 'today':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case '7days':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 6);
        break;
      case 'month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        break;
      case '3months':
        startDate = new Date(now.getFullYear(), now.getMonth() - 2, 1);
        break;
      case 'year':
        startDate = new Date(now.getFullYear(), now.getMonth() - 11, 1);
        break;
      default:
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
    }

    // Get total revenue stats
    const [totalStats] = await db
      .select({
        totalRevenue: sql<number>`coalesce(sum(${pesanan.total}), 0)`,
        totalOrders: sql<number>`count(*)`,
        activeUsers: sql<number>`count(distinct ${pesanan.userId})`
      })
      .from(pesanan)
      .where(
        and(
          gte(pesanan.tanggal, startDate),
          eq(pesanan.status, 'completed')
        )
      );

    const avgOrderValue = Number(totalStats?.totalOrders || 0) > 0
      ? Number(totalStats?.totalRevenue || 0) / Number(totalStats?.totalOrders || 0)
      : 0;

    // Get revenue by user
    const revenueByUser = await db
      .select({
        userId: pesanan.userId,
        totalRevenue: sql<number>`sum(${pesanan.total})`,
        totalOrders: sql<number>`count(*)`
      })
      .from(pesanan)
      .where(
        and(
          gte(pesanan.tanggal, startDate),
          eq(pesanan.status, 'completed')
        )
      )
      .groupBy(pesanan.userId)
      .orderBy(desc(sql`sum(${pesanan.total})`))
      .limit(10);

    // Get user names for revenue by user
    const revenueByUserWithNames = await Promise.all(
      revenueByUser.map(async (item) => {
        const user = await db.query.users.findFirst({
          where: eq(users.id, item.userId)
        });
        return {
          userId: item.userId,
          userName: user?.warungNama || 'Unknown',
          totalRevenue: Number(item.totalRevenue),
          totalOrders: Number(item.totalOrders),
          avgOrderValue: Number(item.totalRevenue) / Number(item.totalOrders)
        };
      })
    );

    // Get revenue by menu - calculate in app since JSON unnesting is problematic
    const completedOrders = await db
      .select()
      .from(pesanan)
      .where(
        and(
          gte(pesanan.tanggal, startDate),
          eq(pesanan.status, 'completed')
        )
      );

    // Aggregate menu revenue
    const menuRevenueMap = new Map<string, { revenue: number; qty: number }>();
    completedOrders.forEach(order => {
      if (Array.isArray(order.items)) {
        order.items.forEach((item: any) => {
          const existing = menuRevenueMap.get(item.menuNama) || { revenue: 0, qty: 0 };
          menuRevenueMap.set(item.menuNama, {
            revenue: existing.revenue + Number(item.subtotal || 0),
            qty: existing.qty + Number(item.qty || 0)
          });
        });
      }
    });

    const revenueByMenuFormatted = Array.from(menuRevenueMap.entries())
      .map(([menuNama, data]) => ({
        menuNama,
        totalRevenue: data.revenue,
        totalQty: data.qty,
        avgPrice: data.qty > 0 ? data.revenue / data.qty : 0
      }))
      .sort((a, b) => b.totalRevenue - a.totalRevenue)
      .slice(0, 20);

    // Get monthly revenue trend for 3months/year view
    let monthlyRevenue: Array<{month: string, revenue: number, orders: number}> = [];
    if (timeRange === '3months' || timeRange === 'year') {
      const months = timeRange === '3months' ? 3 : 12;
      monthlyRevenue = await db
        .select({
          month: sql<string>`to_char(${pesanan.tanggal}, 'Mon YYYY')`,
          revenue: sql<number>`sum(${pesanan.total})`,
          orders: sql<number>`count(*)`
        })
        .from(pesanan)
        .where(
          and(
            gte(pesanan.tanggal, startDate),
            eq(pesanan.status, 'completed')
          )
        )
        .groupBy(sql`to_char(${pesanan.tanggal}, 'Mon YYYY')`)
        .orderBy(sql`to_char(${pesanan.tanggal}, 'Mon YYYY')`);
    }

    return c.json({
      success: true,
      data: {
        totalRevenue: Number(totalStats?.totalRevenue || 0),
        totalOrders: Number(totalStats?.totalOrders || 0),
        activeUsers: Number(totalStats?.activeUsers || 0),
        avgOrderValue,
        revenueByUser: revenueByUserWithNames,
        revenueByMenu: revenueByMenuFormatted,
        monthlyRevenue: monthlyRevenue.map(m => ({
          month: m.month,
          revenue: Number(m.revenue),
          orders: Number(m.orders)
        }))
      }
    });
  } catch (error) {
    console.error('Get revenue analytics error:', error);
    return c.json({ error: 'Failed to fetch revenue analytics' }, 500);
  }
});

// Get system statistics
admin.get('/stats', async (c) => {
  try {
    // Get database statistics
    const [userStats] = await db
      .select({ count: sql<number>`count(*)` })
      .from(users);

    const [deviceStats] = await db
      .select({ count: sql<number>`count(*)` })
      .from(devices);

    const [orderStats] = await db
      .select({
        total: sql<number>`count(*)`,
        completed: sql<number>`count(*) filter (where ${pesanan.status} = 'completed')`,
        pending: sql<number>`count(*) filter (where ${pesanan.status} = 'pending')`,
        cancelled: sql<number>`count(*) filter (where ${pesanan.status} = 'cancelled')`,
        totalRevenue: sql<number>`coalesce(sum(${pesanan.total}), 0)`
      })
      .from(pesanan);

    const [menuStats] = await db
      .select({ count: sql<number>`count(*)` })
      .from(menu);

    const [inventoryStats] = await db
      .select({ count: sql<number>`count(*)` })
      .from(inventory);

    // Get recent activity
    const recentOrders = await db
      .select({
        id: pesanan.id,
        tanggal: pesanan.tanggal,
        total: pesanan.total,
        status: pesanan.status,
        userId: pesanan.userId
      })
      .from(pesanan)
      .orderBy(desc(pesanan.tanggal))
      .limit(10);

    // Get active devices (last 24 hours)
    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const [activeDeviceStats] = await db
      .select({ count: sql<number>`count(*)` })
      .from(devices)
      .where(gte(devices.lastSeenAt, twentyFourHoursAgo));

    return c.json({
      success: true,
      data: {
        database: {
          totalUsers: Number(userStats?.count || 0),
          totalDevices: Number(deviceStats?.count || 0),
          activeDevices: Number(activeDeviceStats?.count || 0),
          totalOrders: Number(orderStats?.total || 0),
          completedOrders: Number(orderStats?.completed || 0),
          pendingOrders: Number(orderStats?.pending || 0),
          cancelledOrders: Number(orderStats?.cancelled || 0),
          totalRevenue: Number(orderStats?.totalRevenue || 0),
          totalMenuItems: Number(menuStats?.count || 0),
          totalInventoryItems: Number(inventoryStats?.count || 0)
        },
        recentActivity: recentOrders.map(order => ({
          id: order.id,
          tanggal: order.tanggal,
          total: order.total,
          status: order.status,
          userId: order.userId
        }))
      }
    });
  } catch (error) {
    console.error('Get system stats error:', error);
    return c.json({ error: 'Failed to fetch system statistics' }, 500);
  }
});

// Get sync logs
admin.get('/sync-logs', async (c) => {
  try {
    const logs = await db.query.syncLogs.findMany({
      orderBy: [desc(syncLogs.timestamp)],
      limit: 100
    });

    return c.json({
      success: true,
      logs
    });
  } catch (error) {
    console.error('Get sync logs error:', error);
    return c.json({ error: 'Failed to fetch sync logs' }, 500);
  }
});

// Get all orders with filtering and pagination
admin.get('/orders', async (c) => {
  try {
    const {
      search = '',
      status,
      dateRange = '7days',
      sortBy = 'tanggal',
      sortOrder = 'desc',
      page = 1,
      limit = 20
    } = c.req.query();

    const pageNum = parseInt(page as string) || 1;
    const limitNum = parseInt(limit as string) || 20;
    const offset = (pageNum - 1) * limitNum;

    // Calculate date range
    const now = new Date();
    let startDate: Date;

    switch (dateRange) {
      case 'today':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case '7days':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 6);
        break;
      case '30days':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 29);
        break;
      case 'all':
      default:
        startDate = new Date(0); // Beginning of time
    }

    // Build query conditions
    const conditions = [
      gte(pesanan.tanggal, startDate)
    ];

    if (status && status !== 'all') {
      conditions.push(eq(pesanan.status, status as 'pending' | 'completed' | 'cancelled'));
    }

    // Get user info for display
    const allPesanan = await db.query.pesanan.findMany({
      where: conditions.length > 1 ? and(...conditions) : conditions[0],
      orderBy: [
        sortBy === 'tanggal' ? desc(pesanan.tanggal) :
        sortBy === 'total' ? desc(pesanan.total) :
        desc(pesanan.status)
      ],
      limit: limitNum,
      offset: offset,
      with: {
        // We'll need to join with users to get user info
      }
    });

    // Get total count for pagination
    const [totalCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(pesanan)
      .where(conditions.length > 1 ? and(...conditions) : conditions[0]);

    // Get user information for each order
    const ordersWithUserInfo = await Promise.all(
      allPesanan.map(async (order) => {
        const user = await db.query.users.findFirst({
          where: eq(users.id, order.userId)
        });

        return {
          ...order,
          userName: user?.warungNama || 'Unknown',
          deviceName: order.deviceId // We could enhance this with device info if needed
        };
      })
    );

    // Apply search filter if provided (done in code for simplicity)
    let filteredOrders = ordersWithUserInfo;
    if (search) {
      const searchLower = (search as string).toLowerCase();
      filteredOrders = ordersWithUserInfo.filter(order =>
        (order.nomorMeja && order.nomorMeja.toLowerCase().includes(searchLower)) ||
        (order.items as any[]).some((item: any) =>
          item.menuNama && item.menuNama.toLowerCase().includes(searchLower)
        ) ||
        (order.userName && order.userName.toLowerCase().includes(searchLower))
      );
    }

    // Apply client-side sorting for complex cases
    if (sortBy === 'total' || sortBy === 'status') {
      filteredOrders.sort((a, b) => {
        let comparison = 0;
        if (sortBy === 'total') {
          comparison = Number(a.total) - Number(b.total);
        } else if (sortBy === 'status') {
          comparison = a.status.localeCompare(b.status);
        }
        return sortOrder === 'asc' ? comparison : -comparison;
      });
    }

    // Apply pagination after filtering
    const paginatedOrders = filteredOrders.slice(offset, offset + limitNum);

    return c.json({
      success: true,
      data: {
        orders: paginatedOrders,
        total: filteredOrders.length,
        page: pageNum,
        limit: limitNum
      }
    });
  } catch (error) {
    console.error('Get orders error:', error);
    return c.json({ error: 'Failed to fetch orders' }, 500);
  }
});

// Update order status
admin.patch('/orders/:id/status', async (c) => {
  try {
    const orderId = parseInt(c.req.param('id'));
    const { status } = await c.req.json();

    if (!['pending', 'completed', 'cancelled'].includes(status)) {
      return c.json({ error: 'Invalid status' }, 400);
    }

    const [updatedOrder] = await db
      .update(pesanan)
      .set({
        status: status as any,
        updatedAt: new Date()
      })
      .where(eq(pesanan.id, orderId))
      .returning();

    if (!updatedOrder) {
      return c.json({ error: 'Order not found' }, 404);
    }

    return c.json({
      success: true,
      message: `Order status updated to ${status}`,
      data: updatedOrder
    });
  } catch (error) {
    console.error('Update order status error:', error);
    return c.json({ error: 'Failed to update order status' }, 500);
  }
});

// Get synced data
admin.get('/synced-data', async (c) => {
  try {
    const allPesanan = await db.query.pesanan.findMany({
      orderBy: [desc(pesanan.createdAt)],
      limit: 50
    });

    const allMenu = await db.query.menu.findMany({
      orderBy: [desc(menu.createdAt)],
      limit: 50
    });

    const allInventory = await db.query.inventory.findMany({
      orderBy: [desc(inventory.createdAt)],
      limit: 50
    });

    return c.json({
      success: true,
      pesanan: allPesanan,
      menu: allMenu,
      inventory: allInventory
    });
  } catch (error) {
    console.error('Get synced data error:', error);
    return c.json({ error: 'Failed to fetch synced data' }, 500);
  }
});

// Delete synced record
admin.delete('/synced-data/:table/:id', async (c) => {
  try {
    const table = c.req.param('table');
    const id = parseInt(c.req.param('id'));

    switch (table) {
      case 'pesanan':
        await db.delete(pesanan).where(eq(pesanan.id, id));
        break;
      case 'menu':
        await db.delete(menu).where(eq(menu.id, id));
        break;
      case 'inventory':
        await db.delete(inventory).where(eq(inventory.id, id));
        break;
      default:
        return c.json({ error: 'Invalid table' }, 400);
    }

    return c.json({
      success: true,
      message: `Record deleted from ${table}`
    });
  } catch (error) {
    console.error('Delete synced record error:', error);
    return c.json({ error: 'Failed to delete record' }, 500);
  }
});

// Conflict Resolution Endpoints

// Get all conflict logs
admin.get('/conflicts', async (c) => {
  try {
    const userId = c.get('userId') as number;

    const conflicts = await db.query.conflictLogs.findMany({
      orderBy: [desc(conflictLogs.timestamp)],
      limit: 100
    });

    return c.json({
      success: true,
      conflicts
    });
  } catch (error) {
    console.error('Get conflicts error:', error);
    return c.json({ error: 'Failed to fetch conflicts' }, 500);
  }
});

// Get conflicts by user
admin.get('/conflicts/user/:userId', async (c) => {
  try {
    const targetUserId = parseInt(c.req.param('userId'));

    const conflicts = await db.query.conflictLogs.findMany({
      where: eq(conflictLogs.userId, targetUserId),
      orderBy: [desc(conflictLogs.timestamp)],
      limit: 100
    });

    return c.json({
      success: true,
      conflicts
    });
  } catch (error) {
    console.error('Get user conflicts error:', error);
    return c.json({ error: 'Failed to fetch user conflicts' }, 500);
  }
});

// Resolve a conflict
admin.post('/conflicts/:conflictId/resolve', async (c) => {
  try {
    const conflictId = parseInt(c.req.param('conflictId'));
    const { resolution, resolvedData, notes } = await c.req.json();
    const resolvedBy = c.get('userId') as number;

    if (!resolution || !['SERVER_WINS', 'CLIENT_WINS', 'MANUAL_MERGE'].includes(resolution)) {
      return c.json({ error: 'Invalid resolution type' }, 400);
    }

    // Get the conflict
    const conflict = await db.query.conflictLogs.findFirst({
      where: eq(conflictLogs.id, conflictId)
    });

    if (!conflict) {
      return c.json({ error: 'Conflict not found' }, 404);
    }

    // Update the conflict log
    await db.update(conflictLogs)
      .set({
        resolution,
        resolvedData: resolvedData || (resolution === 'SERVER_WINS' ? conflict.serverData : conflict.clientData),
        resolvedBy: resolvedBy.toString(),
        resolvedAt: new Date(),
        notes: notes || `Resolved by admin with ${resolution} strategy`
      })
      .where(eq(conflictLogs.id, conflictId));

    // Apply the resolution to the actual entity if needed
    if (resolution === 'SERVER_WINS' || resolution === 'CLIENT_WINS') {
      const winningData = resolution === 'SERVER_WINS' ? conflict.serverData : conflict.clientData;

      switch (conflict.entityType) {
        case 'pesanan':
          await db.update(pesanan)
            .set({
              ...(winningData as any),
              version: sql`${pesanan.version} + 1`,
              lastModifiedBy: 'admin_resolution'
            })
            .where(eq(pesanan.id, conflict.entityId));
          break;

        case 'menu':
          await db.update(menu)
            .set({
              ...(winningData as any),
              version: sql`${menu.version} + 1`,
              lastModifiedBy: 'admin_resolution'
            })
            .where(eq(menu.id, conflict.entityId));
          break;

        case 'inventory':
          await db.update(inventory)
            .set({
              ...(winningData as any),
              version: sql`${inventory.version} + 1`,
              lastModifiedBy: 'admin_resolution'
            })
            .where(eq(inventory.id, conflict.entityId));
          break;
      }
    }

    return c.json({
      success: true,
      message: 'Conflict resolved successfully'
    });
  } catch (error) {
    console.error('Resolve conflict error:', error);
    return c.json({ error: 'Failed to resolve conflict' }, 500);
  }
});

// Get conflict statistics
admin.get('/conflicts/stats', async (c) => {
  try {
    const userId = c.get('userId') as number;

    const [totalConflicts] = await db
      .select({ count: sql<number>`count(*)` })
      .from(conflictLogs);

    const [pendingConflicts] = await db
      .select({ count: sql<number>`count(*)` })
      .from(conflictLogs)
      .where(eq(conflictLogs.resolution, 'PENDING'));

    const [resolvedConflicts] = await db
      .select({ count: sql<number>`count(*)` })
      .from(conflictLogs)
      .where(sql`${conflictLogs.resolution} != 'PENDING'`);

    // Conflict types breakdown
    const conflictTypes = await db
      .select({
        type: conflictLogs.conflictType,
        count: sql<number>`count(*)`
      })
      .from(conflictLogs)
      .groupBy(conflictLogs.conflictType);

    // Resolution breakdown
    const resolutions = await db
      .select({
        resolution: conflictLogs.resolution,
        count: sql<number>`count(*)`
      })
      .from(conflictLogs)
      .groupBy(conflictLogs.resolution);

    return c.json({
      success: true,
      stats: {
        total: totalConflicts.count,
        pending: pendingConflicts.count,
        resolved: resolvedConflicts.count,
        byType: conflictTypes,
        byResolution: resolutions
      }
    });
  } catch (error) {
    console.error('Get conflict stats error:', error);
    return c.json({ error: 'Failed to fetch conflict statistics' }, 500);
  }
});

export default admin;
